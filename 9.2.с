#define _CRT_SECURE_NO_WARNINGS
//#include "stdafx.h"
#include<stdio.h>
#include<conio.h>
#include<math.h>
#include<stdlib.h>
#include"libraries\mystring.h"
#include <locale.h>

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))

#define OK 0
#define Error "Error"
#define ErrorIncorrectInput "Incorrect input"
#define OneSpaceRight " ,!.?-)"
#define OneSpaceLeft "("


int outputText(char* s);
void* mallocList(int count, int sizeOfType);
int solutionFunc(char* str, int length, char*** listStr, int* counter);
int outputLists(char** listWords, int* listCounter, int count);
void freeTwoDArr(char** matrix, int rows);
void freeOneDArr(char* arr);

int main() {
    setlocale(LC_ALL, "Russian");
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    char** listRows;
    int counter, length;
    char str[150];
    gets(str);
    if (inputCount(&length)) {
        outputText(ErrorIncorrectInput);
        _getch();
        return !OK;
    }
    if (!solutionFunc(str, length, &listRows, &counter) && !outputText(join(listRows, counter, "\n"))) {
    }
    else {
        outputText("\n"Error);
    }
    freeTwoDArr(listRows, counter);
    _getch();
    return OK;
}

int inputCount(int* count) {
    printf("Enter count: ");
    return scanf("%i", count) == 0 || *count <= 0;
}

void* mallocList(int count, int sizeOfType) {
    return malloc(sizeOfType * count);
}

int solutionFunc(char* str, int length, char*** listRows, int* counter) {
    replace(str, "  ", " ", -1);
    int n, h, lenRow, lenNewWord, cntWordsRow=0;
    *counter = 0;
    char** listStr = split(str, " ", &n);

    *listRows = (char**)mallocList(n, sizeof(char*));
    char *spaces, ** helpRow = (char**)mallocList(lenStr(str)+1, sizeof(char*));

    lenRow = lenStr(listStr[0]);
    helpRow[cntWordsRow++] = listStr[0];

    for (int i = 1; i <= n; ++i) {
        lenNewWord = lenStr(listStr[i%n]);
        if (length < lenRow + lenNewWord + 1 || i==n) {
            if (cntWordsRow == 1) {
                (*listRows)[(*counter)++] = copyStr(helpRow[0]);
            }
            else {
                h = (length - lenRow) / (cntWordsRow - 1);
                spaces=createNewString(length - 1);
                for (int j = 0; j <= h; addChar(spaces, j++, ' '));
                (*listRows)[*counter] = join(helpRow, cntWordsRow, spaces);
                addChar(spaces, 0, ' ');
                replace((*listRows)[(*counter)++], subStr(spaces, 0, h+1), spaces, length - lenRow - (cntWordsRow - 1) * h);
                freeOneDArr(spaces);
            }
            if (i != n) {
                lenRow = lenNewWord;
                cntWordsRow = 0;
                helpRow[cntWordsRow++] = listStr[i];
            }
        }
        else {
            lenRow += lenNewWord + 1;
            helpRow[cntWordsRow++] = listStr[i];
        }
    }
    freeOneDArr(helpRow);
    freeTwoDArr(listStr, n);
    return OK;
}

int outputLists(char** listWords, int* listCounter, int count) {
    for (int i = 0; i < count; ++i) {
        printf("%s: %i\n", listWords[i], listCounter[i]);
    }
    return OK;
}
int outputText(char* s) {
    printf(s);
    return OK;
}

void freeTwoDArr(char** matrix, int rows) {
    for (int i = 0; i < rows; ++i) {
        free(matrix[i]);
    }
    free(matrix);
}

void freeOneDArr(char* arr) {
    free(arr);
}
